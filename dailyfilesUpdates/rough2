Good â€” you actually gave the code. Now we can stop guessing and start cutting into whatâ€™s wrong.

Short version: **Your controller is fine. Your JSON is fine. Lombok is fine.**
So if youâ€™re still getting `{}` + NULL columns â†’ the problem is somewhere else in the binding / persistence chain.

Letâ€™s stress-test this properly.

---

# ðŸ”Ž First â€” What Should Happen With Your Code

Given:

```java
@PostMapping("/addStudent")
public Student postDetails(@RequestBody Student student) {
    System.out.println(student);
    return studentService.saveDetails(student);
}
```

And JSON:

```json
{
  "mark": 44,
  "name": "asdfa"
}
```

Spring should create:

```java
Student(id=0, mark=44, name=asdfa)
```

Then JPA inserts row with mark + name.

If DB shows NULL â†’ one of these is breaking:

1. JSON not binding
2. Object getting nulled before save
3. JPA mapping mismatch
4. Lombok not working at runtime
5. Wrong request actually hitting backend

Letâ€™s go layer by layer.

---

# âœ… Step 1 â€” Check Console Output (Critical)

You already added:

```java
System.out.println(student);
```

What does it print?

### Case A

```
Student(id=0, mark=0, name=null)
```

â†’ JSON binding failed.

### Case B

```
Student(id=0, mark=44, name=asdfa)
```

â†’ Binding works â†’ problem is in Service/Repository/DB mapping.

Donâ€™t skip this. This single line tells us where the bug lives.

---

# âœ… Step 2 â€” Your Entity Mapping (Thereâ€™s a Subtle Risk)

You wrote:

```java
@GeneratedValue
private int id;
```

You did NOT specify strategy.

Depending on DB, this can misbehave.

Fix it explicitly:

```java
@GeneratedValue(strategy = GenerationType.IDENTITY)
private int id;
```

Especially for MySQL â€” IDENTITY is the safe default.

---

# âœ… Step 3 â€” Primitive Types Can Hide Binding Failures

You used:

```java
private int mark;
```

If binding fails, primitives default to `0`, not `null`.

So you canâ€™t tell if JSON came or not.

Switch to wrapper:

```java
private Integer mark;
```

Now if binding fails â†’ itâ€™ll be `null` â†’ easier debugging.

---

# âœ… Step 4 â€” Verify Service Layer Isnâ€™t Nuking Data

You didnâ€™t paste `StudentService`.

If you wrote something like:

```java
public Student saveDetails(Student student) {
    Student s = new Student();
    return repo.save(s);
}
```

Congrats â€” you just saved an empty object.

Correct service should be:

```java
public Student saveDetails(Student student) {
    return studentRepository.save(student);
}
```

No remapping. No new object creation.

---

# âœ… Step 5 â€” DB Column Names vs Hibernate Naming

You mapped:

```java
@Column(name="ST_MARK")
private int mark;

@Column(name="NAME")
private String name;
```

Check MySQL table:

```sql
DESC student_table;
```

If columns are actually:

```
mark
name
```

â€”not `ST_MARK` / `NAME` â€” Hibernate will insert NULL because mapping doesnâ€™t match.

Either:

### Fix DB

```sql
ST_MARK
NAME
```

OR simplify entity:

```java
private int mark;
private String name;
```

Let Hibernate auto-map.

---

# âœ… Step 6 â€” Confirm Youâ€™re Hitting the Right Endpoint

Test this:

Change method temporarily:

```java
@PostMapping("/addStudent")
public String test(@RequestBody Student student) {
    return "HIT: " + student.getName();
}
```

If Postman still returns `{}` â†’ youâ€™re not hitting this controller.

Common causes:

* Wrong port
* Old app still running
* Multiple services
* Wrong URL

---

# ðŸŽ¯ Most Likely Root Causes (Ranked)

Based on your code, probability order:

1. **Service layer saving empty object**
2. **DB column name mismatch**
3. Lombok not compiling (rare but happens)
4. Wrong endpoint hit
5. Missing IDENTITY strategy (less likely for NULL issue)

`@RequestBody` is already correct â€” so ignore earlier generic advice.

---

# ðŸ§ª Final Isolation Test (Do This)

Bypass service completely:

```java
@Autowired
private StudentRepository repo;

@PostMapping("/addStudent")
public Student postDetails(@RequestBody Student student) {
    System.out.println(student);
    return repo.save(student);
}
```

### If this works

â†’ Your service layer is trash. Fix it.

### If still NULL

â†’ Mapping / DB schema issue.

---

# ðŸ§  Mentor Reality Check

Your debugging approach was surface-level:

You saw:

* 200 OK
* Row inserted
* NULL columns

â€¦and assumed controller binding.

But your controller is already correct.

Real debugging = isolate layers:

1. Controller binding
2. Service mutation
3. Repository save
4. Hibernate mapping
5. DB schema

You skipped straight to assumption.

Thatâ€™s how bugs survive.

---

# If You Want the Exact Kill Shot

Paste:

* `StudentService`
* `StudentRepository`
* MySQL `DESC student_table;`
* Console print output

Iâ€™ll pinpoint the failure line â€” not guess, not theory, exact.
